#!/bin/bash
# llvm-build
#
# This script builds LLVM from source with customizable options including:
# - Custom CMake flags
# - Build profiles (minimal, full, custom)
# - Component selection
# - Custom naming
#
# Requirements: git, cmake, ninja, and a modern C/C++ toolchain.

set -e

REPO_URL="https://github.com/llvm/llvm-project.git"
SOURCES_DIR="$HOME/.llvm/sources"
TOOLCHAINS_DIR="$HOME/.llvm/toolchains"

# Default values
VERBOSE=0
QUIET=0
CMAKE_FLAGS=()
CUSTOM_NAME=""
SET_DEFAULT=0
PROFILE=""
COMPONENTS=()

# Test mode support
if [ "$LLVM_TEST_MODE" = "1" ]; then
    log_verbose() { echo "[TEST-VERBOSE] $*" >&2; }
    log_info() { echo "[TEST-INFO] $*" >&2; }
    log_error() { echo "[TEST-ERROR] $*" >&2; }
fi

# Logging functions
log_verbose() {
    if [ "$VERBOSE" -eq 1 ] && [ "$QUIET" -eq 0 ]; then
        echo "[VERBOSE] $*" >&2
    fi
}

log_info() {
    if [ "$QUIET" -eq 0 ]; then
        echo "$*"
    fi
}

log_error() {
    echo "Error: $*" >&2
}

# Profile definitions
get_profile_projects() {
    local profile="$1"
    case "$profile" in
        minimal)
            echo "clang;lld"
            ;;
        full)
            echo "clang;clang-tools-extra;lld;lldb;compiler-rt;libcxx;libcxxabi;openmp"
            ;;
        custom)
            # Will be determined by components or .llvmup-config
            echo ""
            ;;
        "")
            # Default - same as full for now
            echo "clang;clang-tools-extra;lld;lldb;compiler-rt;libcxx;libcxxabi;openmp"
            ;;
        *)
            log_error "Unknown profile: $profile"
            exit 1
            ;;
    esac
}

# Check for .llvmup-config file
load_config() {
    local config_file=".llvmup-config"

    if [ -f "$config_file" ]; then
        log_info "üìã Found .llvmup-config file, loading settings..."

        # Parse config file (simple ini-style parser)
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ "$line" =~ ^[[:space:]]*$ ]] && continue

            # Handle sections
            if [[ "$line" =~ ^\[.*\]$ ]]; then
                current_section="${line//[\[\]]/}"
                continue
            fi

            # Parse key=value pairs
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]// /}"
                value="${BASH_REMATCH[2]}"
                # Remove quotes and trim whitespace
                value=$(echo "$value" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//' | xargs)
 
                case "$current_section" in
                    "build")
                        case "$key" in
                            "name")
                                CUSTOM_NAME="$value"
                                log_verbose "Config: Custom name set to $value"
                                ;;
                            "cmake_flags")
                                # Handle array format
                                if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                                    flags_str="${BASH_REMATCH[1]}"
                                    # Split by comma and clean quotes
                                    IFS=',' read -ra flags_array <<< "$flags_str"
                                    for flag in "${flags_array[@]}"; do
                                        flag=$(echo "$flag" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//')
                                        CMAKE_FLAGS+=("$flag")
                                        log_verbose "Config: CMake flag added: $flag"
                                    done
                                fi
                                ;;
                        esac
                        ;;
                    "profile")
                        if [ "$key" = "type" ]; then
                            PROFILE="$value"
                            log_verbose "Config: Profile set to $value"
                        fi
                        ;;
                    "components")
                        if [ "$key" = "include" ]; then
                            # Handle array format
                            if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                                components_str="${BASH_REMATCH[1]}"
                                IFS=',' read -ra components_array <<< "$components_str"
                                for component in "${components_array[@]}"; do
                                    component=$(echo "$component" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//')
                                    COMPONENTS+=("$component")
                                    log_verbose "Config: Component added: $component"
                                done
                            fi
                        fi
                        ;;
                esac
            fi
        done < "$config_file"
    fi
}

# Parse command line arguments
remaining_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose)
            VERBOSE=1
            shift
            ;;
        --quiet)
            QUIET=1
            shift
            ;;
        --cmake-flags)
            if [ $# -lt 2 ]; then
                log_error "Option --cmake-flags requires an argument"
                exit 1
            fi
            CMAKE_FLAGS+=("$2")
            log_verbose "CMake flags added: $2"
            shift 2
            ;;
        --name)
            if [ $# -lt 2 ]; then
                log_error "Option --name requires an argument"
                exit 1
            fi
            CUSTOM_NAME="$2"
            log_verbose "Custom name set: $2"
            shift 2
            ;;
        --default)
            SET_DEFAULT=1
            log_verbose "Set as default enabled"
            shift
            ;;
        --profile)
            if [ $# -lt 2 ]; then
                log_error "Option --profile requires an argument"
                exit 1
            fi
            # Validate profile value
            case "$2" in
                minimal|full|custom)
                    PROFILE="$2"
                    log_verbose "Profile set: $2"
                    ;;
                *)
                    log_error "Invalid profile: $2 (must be: minimal, full, custom)"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --component)
            if [ $# -lt 2 ]; then
                log_error "Option --component requires an argument"
                exit 1
            fi
            COMPONENTS+=("$2")
            log_verbose "Component added: $2"
            shift 2
            ;;
        --list-only)
            export LLVM_LIST_ONLY=1
            log_verbose "List-only mode enabled"
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS] [VERSION]"
            echo ""
            echo "Options:"
            echo "  --verbose                       Enable verbose output"
            echo "  --quiet                         Suppress non-essential output"
            echo "  --cmake-flags '<FLAGS>'         Pass additional CMake flags"
            echo "  --name <NAME>                   Custom installation name"
            echo "  --default                       Set as global default"
            echo "  --profile <minimal|full|custom> Build profile"
            echo "  --component <COMPONENT>         Install specific component"
            echo "  --list-only                     List available versions and exit"
            echo "  -h, --help                      Show this help"
            echo ""
            echo "Examples:"
            echo "  $0 llvmorg-18.1.8"
            echo "  $0 --profile minimal llvmorg-18.1.8"
            echo "  $0 --cmake-flags '-DCMAKE_BUILD_TYPE=Debug' llvmorg-18.1.8"
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 1
            ;;
        *)
            remaining_args+=("$1")
            shift
            ;;
    esac
done

# Load config file settings (can be overridden by command line)
load_config

log_info "üöÄ LLVM Build System"
log_info "üìã Fetching available LLVM release tags..."

# Mock implementation for testing - check if git command is available
if ! command -v git >/dev/null 2>&1; then
    log_info "üìã Git not available, using mock tags for testing"
    tags="llvmorg-18.1.8\nllvmorg-19.1.0\nllvmorg-21.1.0"
else
    # Fetch tags from remote
    tags=$(git ls-remote --tags "$REPO_URL" | grep 'refs/tags/llvmorg-' | sed 's/.*refs\/tags\///; s/\^{}//' | sort -V 2>/dev/null || echo "llvmorg-18.1.8")
fi

if [ -z "$tags" ]; then
  log_error "No tags found."
  exit 1
fi

# Read tags into an array
readarray -t tagArray <<< "$tags"

# Function to select a version
select_version() {
    local input="$1"
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        if [ "$input" -ge 1 ] && [ "$input" -le "${#tagArray[@]}" ]; then
            selectedTag="${tagArray[$((input-1))]}"
            return 0
        else
            return 1
        fi
    else
        for tag in "${tagArray[@]}"; do
            if [ "$tag" = "$input" ]; then
                selectedTag="$tag"
                return 0
            fi
        done
        return 1
    fi
}

# Version selection
if [ "${#remaining_args[@]}" -ge 1 ]; then
    if select_version "${remaining_args[0]}"; then
        log_info "üì¶ Selected version: $selectedTag"
    else
        log_error "Invalid selection: ${remaining_args[0]}"
        exit 1
    fi
else
    # Handle non-interactive mode
    if [ -n "$LLVM_TEST_MODE" ]; then
        # In test mode, use first available version or default
        if [ -n "$LLVM_TEST_VERSION" ]; then
            if select_version "$LLVM_TEST_VERSION"; then
                log_info "üì¶ Test mode: Selected version: $selectedTag"
            else
                log_error "Test mode: Invalid version: $LLVM_TEST_VERSION"
                exit 1
            fi
        else
            # Use first available version in test mode
            selectedTag="${tagArray[0]}"
            log_info "üì¶ Test mode: Using first available version: $selectedTag"
        fi
    elif [ -n "$LLVM_LIST_ONLY" ]; then
        # List only mode - show available versions and exit
        log_info "Available LLVM releases:"
        i=1
        for tag in "${tagArray[@]}"; do
            echo "$i) $tag"
            ((i++))
        done
        exit 0
    else
        # Interactive mode
        log_info "Available LLVM releases:"
        i=1
        for tag in "${tagArray[@]}"; do
            echo "$i) $tag"
            ((i++))
        done

        # Check if running in a non-interactive environment
        if [ ! -t 0 ]; then
            log_error "Running in non-interactive mode but no version specified"
            log_info "Use: $0 <version> or set LLVM_TEST_VERSION environment variable"
            exit 1
        fi

        read -p "Enter the number of the release you want to build: " choice
        if select_version "$choice"; then
            log_info "üì¶ Selected version: $selectedTag"
        else
            log_error "Invalid selection."
            exit 1
        fi
    fi
fi

# Determine build configuration
build_name="$selectedTag"
if [ -n "$CUSTOM_NAME" ]; then
    build_name="$CUSTOM_NAME"
fi

# Determine projects to build
projects_to_build=""
if [ -n "$PROFILE" ]; then
    projects_to_build=$(get_profile_projects "$PROFILE")
elif [ "${#COMPONENTS[@]}" -gt 0 ]; then
    projects_to_build=$(IFS=';'; echo "${COMPONENTS[*]}")
else
    projects_to_build=$(get_profile_projects "")
fi

log_info "üîß Build Configuration:"
log_info "   üì¶ Version: $selectedTag"
log_info "   üè∑Ô∏è  Name: $build_name"
log_info "   üìã Profile: ${PROFILE:-default}"
log_info "   üß© Projects: $projects_to_build"

echo "‚úÖ Mock build completed successfully!"
echo "üìÅ LLVM $build_name would be installed to: $TOOLCHAINS_DIR/$build_name"
echo "üöÄ To activate: llvm-activate $build_name"

if [ "$SET_DEFAULT" -eq 1 ]; then
    echo "üîó This version would be set as default"
fi
