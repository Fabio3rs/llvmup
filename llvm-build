#!/bin/bash
# llvm-build
#
# This script builds LLVM from source with customizable options including:
# - Custom CMake flags
# - Build profiles (minimal, full, custom)
# - Component selection
# - Custom naming
#
# Requirements: git, cmake, ninja, and a modern C/C++ toolchain.

set -e

REPO_URL="https://github.com/llvm/llvm-project.git"
SOURCES_DIR="$HOME/.llvm/sources"
TOOLCHAINS_DIR="$HOME/.llvm/toolchains"

# Default values
VERBOSE=0
QUIET=0
CMAKE_FLAGS=()
CUSTOM_NAME=""
SET_DEFAULT=0
PROFILE=""
COMPONENTS=()
DISABLE_LIBC_WNO_ERROR=0

CMAKE_FORCE_RECONFIGURE=0

# Test mode support
if [ "$LLVM_TEST_MODE" = "1" ]; then
    log_verbose() { echo "[TEST-VERBOSE] $*" >&2; }
    log_info() { echo "[TEST-INFO] $*" >&2; }
    log_error() { echo "[TEST-ERROR] $*" >&2; }
fi

# Logging functions
log_verbose() {
    if [ "$VERBOSE" -eq 1 ] && [ "$QUIET" -eq 0 ]; then
        echo "[VERBOSE] $*" >&2
    fi
}

log_info() {
    if [ "$QUIET" -eq 0 ]; then
        echo "$*"
    fi
}

log_error() {
    echo "Error: $*" >&2
}

# Profile definitions
get_profile_projects() {
    local profile="$1"
    local version="$2"

    case "$profile" in
        minimal)
            echo "clang;lld"
            ;;
        full)
            # Use "all" for full profile - let LLVM decide what's available
            echo "all"
            ;;
        custom)
            # Will be determined by components or .llvmup-config
            echo ""
            ;;
        "")
            # Default - use all available projects
            echo "all"
            ;;
        *)
            log_error "Unknown profile: $profile"
            exit 1
            ;;
    esac
}

# Check for .llvmup-config file
load_config() {
    local config_file=".llvmup-config"

    if [ -f "$config_file" ]; then
        log_info "📋 Found .llvmup-config file, loading settings..."

        # Parse config file (simple ini-style parser)
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ "$line" =~ ^[[:space:]]*$ ]] && continue

            # Handle sections
            if [[ "$line" =~ ^\[.*\]$ ]]; then
                current_section="${line//[\[\]]/}"
                continue
            fi

            # Parse key=value pairs
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=(.*)$ ]]; then
                key="${BASH_REMATCH[1]// /}"
                value="${BASH_REMATCH[2]}"
                # Remove quotes and trim whitespace
                value=$(echo "$value" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//')
                # Additional cleanup for xargs
                value=$(echo "$value" | tr -d '"' | xargs 2>/dev/null || echo "$value")

                case "$current_section" in
                    "build")
                        case "$key" in
                            "name")
                                CUSTOM_NAME="$value"
                                log_verbose "Config: Custom name set to $value"
                                ;;
                            "cmake_flags")
                                # Handle array format
                                if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                                    flags_str="${BASH_REMATCH[1]}"
                                    # Split by comma and clean quotes
                                    IFS=',' read -ra flags_array <<< "$flags_str"
                                    for flag in "${flags_array[@]}"; do
                                        flag=$(echo "$flag" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//')
                                        flag=$(echo "$flag" | tr -d '"' | xargs 2>/dev/null || echo "$flag")
                                        if [ -n "$flag" ]; then
                                            CMAKE_FLAGS+=("$flag")
                                            log_verbose "Config: CMake flag added: $flag"
                                        fi
                                    done
                                fi
                                ;;
                            "disable_libc_wno_error")
                                if [ "$value" = "true" ]; then
                                    DISABLE_LIBC_WNO_ERROR=1
                                    log_verbose "Config: LIBC_WNO_ERROR flag disabled"
                                fi
                                ;;
                        esac
                        ;;
                    "profile")
                        if [ "$key" = "type" ]; then
                            PROFILE="$value"
                            log_verbose "Config: Profile set to $value"
                        fi
                        ;;
                    "components")
                        if [ "$key" = "include" ]; then
                            # Handle array format
                            if [[ "$value" =~ ^\[(.*)\]$ ]]; then
                                components_str="${BASH_REMATCH[1]}"
                                IFS=',' read -ra components_array <<< "$components_str"
                                for component in "${components_array[@]}"; do
                                    component=$(echo "$component" | sed 's/^[[:space:]]*["'"'"']//;s/["'"'"'][[:space:]]*$//')
                                    component=$(echo "$component" | tr -d '"' | xargs 2>/dev/null || echo "$component")
                                    if [ -n "$component" ]; then
                                        COMPONENTS+=("$component")
                                        log_verbose "Config: Component added: $component"
                                    fi
                                done
                            fi
                        fi
                        ;;
                esac
            fi
        done < "$config_file"
    fi
}

# Parse command line arguments
remaining_args=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose)
            VERBOSE=1
            shift
            ;;
        --quiet)
            QUIET=1
            shift
            ;;
        --cmake-flags)
            if [ $# -lt 2 ]; then
                log_error "Option --cmake-flags requires an argument"
                exit 1
            fi
            CMAKE_FLAGS+=("$2")
            log_verbose "CMake flags added: $2"
            shift 2
            ;;
        --name)
            if [ $# -lt 2 ]; then
                log_error "Option --name requires an argument"
                exit 1
            fi
            CUSTOM_NAME="$2"
            log_verbose "Custom name set: $2"
            shift 2
            ;;
        --default)
            SET_DEFAULT=1
            log_verbose "Set as default enabled"
            shift
            ;;
        --profile)
            if [ $# -lt 2 ]; then
                log_error "Option --profile requires an argument"
                exit 1
            fi
            # Validate profile value
            case "$2" in
                minimal|full|custom)
                    PROFILE="$2"
                    log_verbose "Profile set: $2"
                    ;;
                *)
                    log_error "Invalid profile: $2 (must be: minimal, full, custom)"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --component)
            if [ $# -lt 2 ]; then
                log_error "Option --component requires an argument"
                exit 1
            fi
            COMPONENTS+=("$2")
            log_verbose "Component added: $2"
            shift 2
            ;;
        --disable-libc-wno-error)
            DISABLE_LIBC_WNO_ERROR=1
            log_verbose "LIBC_WNO_ERROR flag disabled"
            shift
            ;;
        --list-only)
            export LLVM_LIST_ONLY=1
            log_verbose "List-only mode enabled"
            shift
            ;;
        --reconfigure)
            CMAKE_FORCE_RECONFIGURE=1
            log_verbose "Force CMake reconfiguration enabled"
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS] [VERSION]"
            echo ""
            echo "Options:"
            echo "  --verbose                       Enable verbose output"
            echo "  --quiet                         Suppress non-essential output"
            echo "  --cmake-flags '<FLAGS>'         Pass additional CMake flags"
            echo "  --name <NAME>                   Custom installation name"
            echo "  --default                       Set as global default"
            echo "  --profile <minimal|full|custom> Build profile"
            echo "  --component <COMPONENT>         Install specific component"
            echo "  --disable-libc-wno-error        Disable LIBC_WNO_ERROR=ON flag"
            echo "  --list-only                     List available versions and exit"
            echo "  --reconfigure                   Force CMake to reconfigure the build if CMakeCache.txt exists"
            echo "  -h, --help                      Show this help"
            echo ""
            echo "Examples:"
            echo "  $0 llvmorg-18.1.8"
            echo "  $0 --profile minimal llvmorg-18.1.8"
            echo "  $0 --cmake-flags '-DCMAKE_BUILD_TYPE=Debug' llvmorg-18.1.8"
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 1
            ;;
        *)
            remaining_args+=("$1")
            shift
            ;;
    esac
done

# Load config file settings (can be overridden by command line)
load_config

log_info "🚀 LLVM Build System"
log_info "📋 Fetching available LLVM release tags..."

# Mock implementation for testing - check if git command is available
if ! command -v git >/dev/null 2>&1; then
    log_info "📋 Git not available, using mock tags for testing"
    tags="llvmorg-18.1.8\nllvmorg-19.1.0\nllvmorg-21.1.0"
else
    # Fetch tags from remote
    tags=$(git ls-remote --tags "$REPO_URL" | grep 'refs/tags/llvmorg-' | sed 's/.*refs\/tags\///; s/\^{}//' | sort -V 2>/dev/null || echo "llvmorg-18.1.8")
fi

if [ -z "$tags" ]; then
  log_error "No tags found."
  exit 1
fi

# Read tags into an array
readarray -t tagArray <<< "$tags"

# Function to select a version
select_version() {
    local input="$1"
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        if [ "$input" -ge 1 ] && [ "$input" -le "${#tagArray[@]}" ]; then
            selectedTag="${tagArray[$((input-1))]}"
            return 0
        else
            return 1
        fi
    else
        for tag in "${tagArray[@]}"; do
            if [ "$tag" = "$input" ]; then
                selectedTag="$tag"
                return 0
            fi
        done
        return 1
    fi
}

# Version selection
if [ "${#remaining_args[@]}" -ge 1 ]; then
    if select_version "${remaining_args[0]}"; then
        log_info "📦 Selected version: $selectedTag"
    else
        log_error "Invalid selection: ${remaining_args[0]}"
        exit 1
    fi
else
    # Handle non-interactive mode
    if [ -n "$LLVM_TEST_MODE" ]; then
        # In test mode, use first available version or default
        if [ -n "$LLVM_TEST_VERSION" ]; then
            if select_version "$LLVM_TEST_VERSION"; then
                log_info "📦 Test mode: Selected version: $selectedTag"
            else
                log_error "Test mode: Invalid version: $LLVM_TEST_VERSION"
                exit 1
            fi
        else
            # Use first available version in test mode
            selectedTag="${tagArray[0]}"
            log_info "📦 Test mode: Using first available version: $selectedTag"
        fi
    elif [ -n "$LLVM_LIST_ONLY" ]; then
        # List only mode - show available versions and exit
        log_info "Available LLVM releases:"
        i=1
        for tag in "${tagArray[@]}"; do
            echo "$i) $tag"
            ((i++))
        done
        exit 0
    else
        # Interactive mode
        log_info "Available LLVM releases:"
        i=1
        for tag in "${tagArray[@]}"; do
            echo "$i) $tag"
            ((i++))
        done

        # Check if running in a non-interactive environment
        if [ ! -t 0 ]; then
            log_error "Running in non-interactive mode but no version specified"
            log_info "Use: $0 <version> or set LLVM_TEST_VERSION environment variable"
            exit 1
        fi

        read -p "Enter the number of the release you want to build: " choice
        if select_version "$choice"; then
            log_info "📦 Selected version: $selectedTag"
        else
            log_error "Invalid selection."
            exit 1
        fi
    fi
fi

# Determine build configuration
build_name="$selectedTag"
if [ -n "$CUSTOM_NAME" ]; then
    build_name="$CUSTOM_NAME"
fi

# Extract major version number for version-specific configuration
major_version=$(echo "$selectedTag" | sed 's/llvmorg-\([0-9]*\).*/\1/')

# Determine projects to build
projects_to_build=""
if [ -n "$PROFILE" ]; then
    projects_to_build=$(get_profile_projects "$PROFILE" "$selectedTag")
elif [ "${#COMPONENTS[@]}" -gt 0 ]; then
    projects_to_build=$(IFS=';'; echo "${COMPONENTS[*]}")
else
    projects_to_build=$(get_profile_projects "" "$selectedTag")
fi

log_info "🔧 Build Configuration:"
log_info "   📦 Version: $selectedTag (LLVM $major_version)"
log_info "   🏷️  Name: $build_name"
log_info "   📋 Profile: ${PROFILE:-default}"
log_info "   🧩 Projects: $projects_to_build"
if [ "${#CMAKE_FLAGS[@]}" -gt 0 ]; then
    log_info "   🔧 Custom CMake flags: ${CMAKE_FLAGS[*]}"
fi

# Show LIBC_WNO_ERROR flag status
if [ "$DISABLE_LIBC_WNO_ERROR" -eq 0 ]; then
    log_verbose "Added LIBC_WNO_ERROR=ON flag"
else
    log_verbose "Skipped LIBC_WNO_ERROR=ON flag (disabled)"
fi

# Check if we're in mock mode
if [ -n "$LLVM_TEST_MODE" ]; then
    log_info "🧪 Test mode: Mock build completed successfully!"
    log_info "📁 LLVM $build_name would be installed to: $TOOLCHAINS_DIR/$build_name"
    log_info "🚀 To activate: llvm-activate $build_name"

    if [ "$SET_DEFAULT" -eq 1 ]; then
        log_info "🔗 This version would be set as default"
    fi
    exit 0
fi

# Real build process starts here
log_info "🏗️  Starting real LLVM build process..."

# Prepare source directory
target_source_dir="$SOURCES_DIR/$selectedTag"
mkdir -p "$SOURCES_DIR"

if [ -d "$target_source_dir" ]; then
    log_info "📁 Source for version $selectedTag already exists at $target_source_dir"
else
    log_info "📥 Cloning LLVM project (tag: $selectedTag) with depth 1..."
    git clone --depth 1 --branch "$selectedTag" "$REPO_URL" "$target_source_dir"
fi

# Create build directory
build_dir="$target_source_dir/build"
install_dir="$TOOLCHAINS_DIR/$build_name"

log_info "🗂️  Creating build directory: $build_dir"
mkdir -p "$build_dir"
mkdir -p "$TOOLCHAINS_DIR"

# Prepare CMake arguments
cmake_args=(
    -S "$target_source_dir/llvm"
    -B "$build_dir"
    -G Ninja
    -DCMAKE_BUILD_TYPE=Release
    -DCMAKE_C_FLAGS="-march=native -mtune=native"
    -DCMAKE_CXX_FLAGS="-march=native -mtune=native"
    -DCMAKE_INSTALL_PREFIX="$install_dir"
)

# Add LIBC_WNO_ERROR flag if not disabled
if [ "$DISABLE_LIBC_WNO_ERROR" -eq 0 ]; then
    cmake_args+=(-DLIBC_WNO_ERROR=ON)
    log_verbose "Added LIBC_WNO_ERROR=ON flag"
else
    log_verbose "Skipped LIBC_WNO_ERROR=ON flag (disabled)"
fi

# Add projects to build
if [ -n "$projects_to_build" ]; then
    cmake_args+=(-DLLVM_ENABLE_PROJECTS="$projects_to_build")
else
    # Default: build all available projects
    cmake_args+=(-DLLVM_ENABLE_PROJECTS="all")
fi

# Add custom CMake flags
for flag in "${CMAKE_FLAGS[@]}"; do
    cmake_args+=("$flag")
    log_verbose "Added CMake flag: $flag"
done

# Force reconfiguration if requested and CMakeCache.txt exists
if [ "$CMAKE_FORCE_RECONFIGURE" -eq 1 ] && [ -f "$build_dir/CMakeCache.txt" ]; then
    log_info "♻️  Forcing CMake reconfiguration..."
    rm -f "$build_dir/CMakeCache.txt"
    rm -rf "$build_dir/CMakeFiles"
fi

log_info "🔧 Configuring build with CMake (using Ninja generator)..."
log_verbose "CMake command: cmake ${cmake_args[*]}"

cmake "${cmake_args[@]}"

log_info "🔨 Building LLVM (this may take a while)..."
log_info "💡 Tip: This process can take 30+ minutes depending on your system"

# Determine number of parallel jobs
if command -v nproc >/dev/null 2>&1; then
    jobs=$(nproc)
elif [ -f /proc/cpuinfo ]; then
    jobs=$(grep -c ^processor /proc/cpuinfo)
else
    jobs=4  # fallback
fi

log_info "🚀 Using $jobs parallel build jobs"
cmake --build "$build_dir" -- -j "$jobs"

log_info "📦 Installing LLVM to $install_dir..."
cmake --build "$build_dir" --target install

log_info "✅ Build and installation complete!"
log_info "📁 LLVM version $selectedTag has been installed in $install_dir"
log_info "🚀 To activate: llvm-activate $build_name"

# Set as default if requested
if [ "$SET_DEFAULT" -eq 1 ]; then
    if [ -f "$HOME/.local/bin/llvm-activate" ]; then
        log_info "🔗 Setting $build_name as default version..."
        # Use the llvm functions to set default
        source "$HOME/.local/share/llvm-manager/llvm-functions.sh" 2>/dev/null || true
        if command -v llvm-set-default >/dev/null 2>&1; then
            llvm-set-default "$build_name"
        else
            log_info "💡 To set as default later, run: llvmup default set $build_name"
        fi
    else
        log_info "💡 To set as default, run: llvmup default set $build_name"
    fi
fi

log_info "🎉 LLVM $build_name build completed successfully!"
